## Interfaces

### Motivation

- Die `Tetris`-Klasse verwendet einen `FairLetterSupplier`:

```java
public class Tetris {
    // ...
    private final FairLetterSupplier letterSupplier;
    // ...

    public Tetris() {
        //...
        letterSupplier = new FairLetterSupplier();
        //...
    }
}
```

- In Tetris-Lingo ist ein "Letter" eine Zahl zwischen 1 und 7
  - stellvertretend f√ºr die (unrotierten) Basis-Formen I, J, L, O, S, T, Z
- Angenommen, Spieler 2 ist deutlich besser als Spieler 1
  - Spieler 1 soll weiterhin einen `FairLetterSupplier` verwenden
  - Spieler 2 soll einen neuen `UnfairLetterSupplier` verwenden:

```java
public class UnfairLetterSupplier {
    // potenziell beliebig lange Pausen zwischen guten Steinen
    public int nextLetter() {
        return 1 + (int) (Math.random() * 7);
    }
}
```

- M√ºssen wir daf√ºr die komplette `Tetris`-Klasse duplizieren?!?

<table>
<tr>
<th>FairTetris</th>
<th>UnfairTetris</th>
</tr>
<tr>
<td>

```java
public class FairTetris {
    // ...
    private final FairLetterSupplier letterSupplier;
    // ...

    public FairTetris() {
        //...
        letterSupplier = new FairLetterSupplier();
        //...
    }
}
```

</td>
<td>

```java
public class UnfairTetris {
    // ...
    private final UnfairLetterSupplier letterSupplier;
    // ...

    public UnfairTetris() {
        //...
        letterSupplier = new UnfairLetterSupplier();
        //...
    }
}
```

</td>
</tr>
</table>

- Dann m√ºssten wir ab sofort:
  - jedes neue Feature in *beide* Tetris-Klassen einbauen
  - jeden gefundenen Bug in *beiden* Tetris-Klassen fixen
  - jedes Refactoring in *beiden* Tetris-Klassen vornehmen
  - ...ein Wartungs-Albtraum!
- Ideal w√§re *eine* `Tetris`-Klasse, die mit *beliebigen* `LetterSupplier`n zurechtkommt:

```java
public class Tetris {
    // ...
    private final LetterSupplier letterSupplier;
    // ...

    public Tetris(LetterSupplier letterSupplier) {
        //...
        this.letterSupplier = letterSupplier;
        //...
    }
}
```

- Der neue Typ `LetterSupplier` ist keine konkrete Klasse, sondern ein abstraktes Interface:

```java
public abstract interface LetterSupplier {

    public abstract int nextLetter();
}
```

- Die beiden konkreten Klassen m√ºssen das abstrakte Interface ausdr√ºcklich implementieren:

<table>
<tr>
<th>FairLetterSupplier</th>
<th>UnfairLetterSupplier</th>
</tr>
<tr>
<td>

```java
public class FairLetterSupplier
      implements LetterSupplier {
    // ...
}
```

</td>
<td>

```java
public class UnfairLetterSupplier
        implements LetterSupplier {
    // ...
}
```

</td>
</tr>
</table>

- Zuletzt m√ºssen wir beim Erzeugen der `Tetris`-Objekte konkrete `Un/FairLetterSupplier`-Objekte √ºbergeben:

```java
Tetris[] games = {
    new Tetris(new   FairLetterSupplier()),
    new Tetris(new UnfairLetterSupplier()),
};
```

- `new LetterSupplier()` w√ºrde *nicht* funktionieren!

> **√úbung:**
> - Schreibe eine dritte Klasse `CheatingLetterSupplier`
>   - `nextLetter` soll bei jedem 2. Aufruf (und sonst nicht!) den langen `I`-Stein liefern
>   - Benutze `CheatingLetterSupplier` gem√§√ü obiger Anleitung f√ºr Spieler 1

### Eigenschaften von Interfaces

- Ein Interface hat:
  - *keine* Zustandsfelder
  - *keine* Konstruktoren
  - *keine* Methodenr√ºmpfe ¬π
- Von Interfaces kann man *keine* Objekte erzeugen
  - Ein Interface definiert lediglich einen *statischen* Supertyp f√ºr alle implementierenden Klassen
  - *Dynamisch* getypte Programmiersprachen haben keine Interfaces (siehe JavaScript vs. TypeScript)
- Interfaces sind grunds√§tzlich abstrakt
  - egal ob man `abstract interface` oder nur `interface` schreibt
- Interface-Methoden sind grunds√§tzlich √∂ffentlich und abstrakt
  - egal ob man `public` und/oder `abstract` schreibt

¬π Seit Java 8 k√∂nnen Interfaces auch konkrete `default`-Methoden (mit R√ºmpfen) enthalten

### Bekannte Informatiker

- Starte die (`main`-Methode in der) Klasse `Informatiker`
  - Probiere aus, was die 4 Buttons bewirken
- Studiere das Interface `Vergleicher` und seine implementierenden Klassen:
  - Rechte Maustaste in Zeile 3 auf `Vergleicher`
  - Go To
  - Implementations
- Schreibe eine Klasse `PerVorname`, welche die Vornamen der Personen miteinander vergleicht
  - Erg√§nze das Array `Vergleicher[] alleVergleicher` in der Klasse `Informatiker` passend
  - Dann erscheint ein entsprechender Button an der grafischen Oberfl√§che
  - Das musst du im Folgenden auch f√ºr alle weiteren Vergleicher tun!
- Schreibe eine Klasse `PerGeschlecht`, welche Frauen vor M√§nnern einstuft
- Kannst du durch geschickten Einsatz der Klasse `Zweistufig` auch 3 Vergleicher hintereinander schalten?
  - erst per Geschlecht
  - dann per Alter
  - dann per Nachname
- Schreibe eine Klasse `Umgekehrt`, welche sich genau umgekehrt zu einem anderen
Vergleicher verh√§lt
  - Beispielsweise soll `new Umgekehrt(new PerAlter())` junge Personen vor alten
einstufen
  - Als Inspiration kann hierbei die (deutlich kompliziertere) Klasse `Zweistufig` dienen

### JSON

- Starte die (`main`-Methode in der) Klasse `Freddy`
  - Kennst du das JSON-Austauschformat?
  - F√§llt dir in der Konsole **ein Fehler** auf?
- Studiere folgende Typen in dieser Reihenfolge:
  1. `Wert`
  2. `Zahl`
  3. `Zeichenkette`
  4. `Symbolisch`
  5. `Objekt`
- Behebe **o.g. Fehler**, der dir in der Konsole aufgefallen war
- F√ºge 2 weitere Konstruktoren zu `Objekt` zu
  - damit auch 4 und 5 Schl√ºssel/Wert-P√§rchen funktionieren
- F√ºge einen neuen Typ `class Array implements Wert` hinzu
  - z.B. `new Array(Symbolisch.TRUE, new Zahl(42), new Zeichenkette("test")).stringify()`
  - sollte `[true, 42.0, "test"]` ergeben
  - Tipp: Der Parametertyp `Wert...` erlaubt beliebig viele Argumente
- Die Methode `Zeichenkette.appendLiteral` kann noch nicht mit Sonderzeichen umgehen:
  - G√§nsef√º√üchen
  - Zeilenumbruch
  - Backslash
  - ...
  - üèÜ Behandle diese Sonderzeichen sinnvoll
    - https://www.google.com/search?q=escape+sequenz
- Bisher schreibt `append` alles in eine Zeile
  - üèÜ Sch√∂ner w√§re eine Zeile pro Schl√ºssel/Wert-P√§rchen bzw. Array-Eintrag
